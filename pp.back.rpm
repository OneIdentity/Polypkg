# rpm backend
#  The packages generated by this backend are suitable for
#  both redhat and suse.
# http://www.novell.com/coolsolutions/feature/11256.html

pp_platforms="$pp_platforms rpm"

#@ pp_backend_rpm_detect(uname_s): return true if this platform uses RPM
#    -- specific test for debian
pp_backend_rpm_detect () {
    test x"$1" = x"Linux" -a ! -f /etc/debian_version
}

#@ pp_backend_rpm_init(): initialises rpm backend variables
pp_backend_rpm_init () {

    pp_rpm_version=
    pp_rpm_summary=
    pp_rpm_description=
    pp_rpm_group="Applications/Internet"
    pp_rpm_license="Unspecified"
    pp_rpm_vendor=
    pp_rpm_url=
    pp_rpm_packager=
    pp_rpm_provides=
    pp_rpm_requires=
    pp_rpm_requires_pre=
    pp_rpm_requires_post=
    pp_rpm_requires_preun=
    pp_rpm_requires_postun=
    pp_rpm_release=
    pp_rpm_epoch=
    pp_rpm_dev_group="Development/Libraries"
    pp_rpm_dbg_group="Development/Tools"
    pp_rpm_doc_group="Documentation"
    pp_rpm_dev_description=
    pp_rpm_dbg_description=
    pp_rpm_doc_description=
    pp_rpm_dev_requires=
    pp_rpm_dev_requires_pre=
    pp_rpm_dev_requires_post=
    pp_rpm_dev_requires_preun=
    pp_rpm_dev_requires_postun=
    pp_rpm_dbg_requires=
    pp_rpm_dbg_requires_pre=
    pp_rpm_dbg_requires_post=
    pp_rpm_dbg_requires_preun=
    pp_rpm_dbg_requires_postun=
    pp_rpm_doc_requires=
    pp_rpm_doc_requires_pre=
    pp_rpm_doc_requires_post=
    pp_rpm_doc_requires_preun=
    pp_rpm_doc_requires_postun=
    pp_rpm_dev_provides=
    pp_rpm_dbg_provides=
    pp_rpm_doc_provides=

    pp_rpm_autoprov=
    pp_rpm_autoreq=
    pp_rpm_autoreqprov=

    pp_rpm_dbg_pkgname=debug
    pp_rpm_dev_pkgname=devel
    pp_rpm_doc_pkgname=doc

    pp_rpm_defattr_uid=root
    pp_rpm_defattr_gid=root

    pp_rpm_detect_arch
    pp_rpm_detect_distro
    pp_rpm_rpmbuild=`pp_rpm_detect_rpmbuild`

    # SLES8 doesn't always come with readlink
    test -x /usr/bin/readlink -o -x /bin/readlink ||
        pp_readlink_fn=pp_ls_readlink
}

#@ pp_rpm_detect_arch(): sets $pp_rpm_arch to current RPM architecture
pp_rpm_detect_arch () {
    pp_rpm_arch=auto

    #-- Find the default native architecture that RPM is configured to use
    cat <<-. >$pp_wrkdir/dummy.spec
	Name: dummy
	Version: 1
	Release: 1
	Summary: dummy
	Group: ${pp_rpm_group}
	License: ${pp_rpm_license}
	%description
	dummy
.
    $pp_opt_debug && cat $pp_wrkdir/dummy.spec
    pp_rpm_arch_local=`rpm -q --qf '%{arch}\n' --specfile $pp_wrkdir/dummy.spec`
    rm $pp_wrkdir/dummy.spec

    #-- Ask the kernel what machine architecture is in use
    local arch
    for arch in "`uname -m`" "`uname -p`"; do
	case "$arch" in
	    i?86)
		pp_rpm_arch_std=i386
		break
		;;
	    x86_64|ppc|ppc64|ppc64le|ia64|s390|s390x)
		pp_rpm_arch_std="$arch"
		break
		;;
	    powerpc)
		# Probably AIX
		case "`/usr/sbin/lsattr -El proc0 -a type -F value`" in
		    PowerPC_POWER*)	pp_rpm_arch_std=ppc64;;
		    *)			pp_rpm_arch_std=ppc;;
		esac
		break
		;;
	    *)	pp_rpm_arch_std=unknown
		;;
	esac
    done

    #-- Later on, when files are processed, we use 'file' to determine
    #   what platform ABIs are used. This is used when pp_rpm_arch == auto
    pp_rpm_arch_seen=
}

#@ pp_rpm_detect_distro(): sets $pp_rpm_distro to a short distro name or ''
pp_rpm_detect_distro () {
    pp_rpm_distro=
    if test -f /etc/whitebox-release; then
       pp_rpm_distro=`awk '
          /^White Box Enterprise Linux release/ { print "wbel" $6; exit; }
       ' /etc/whitebox-release`
    elif test -f /etc/mandrakelinux-release; then
       pp_rpm_distro=`awk '
          /^Mandrakelinux release/ { print "mand" $3; exit; }
       ' /etc/mandrake-release`
    elif test -f /etc/mandrake-release; then
       pp_rpm_distro=`awk '
          /^Linux Mandrake release/ { print "mand" $4; exit; }
          /^Mandrake Linux release/ { print "mand" $4; exit; }
       ' /etc/mandrake-release`
    elif test -f /etc/fedora-release; then
       pp_rpm_distro=`awk '
          /^Fedora Core release/ { print "fc" $4; exit; }
          /^Fedora release/ { print "f" $3; exit; }
       ' /etc/fedora-release`
    elif test -f /etc/redhat-release; then
       pp_rpm_distro=`sed -n \
         -e 's/^Red Hat Linux.*release \([0-9][0-9\.]*\).*/rh\1/p' \
         -e 's/^Red Hat Enterprise Linux.*release \([0-9][0-9\.]*\).*/rhel\1/p' \
         -e 's/^CentOS.*release \([0-9][0-9\.]*\).*/centos\1/p' \
       /etc/redhat-release`
    elif test -f /etc/SuSE-release; then
       pp_rpm_distro=`awk '
          /^SuSE Linux [0-9]/ { print "suse" $3; exit; }
          /^SUSE LINUX [0-9]/ { print "suse" $3; exit; }
          /^openSUSE [0-9]/   { print "suse" $2; exit; }
          /^S[uU]SE Linux Enterprise Server [0-9]/ { print "sles" $5; exit; }
          /^S[uU]SE LINUX Enterprise Server [0-9]/ { print "sles" $5; exit; }
          /^SuSE SLES-[0-9]/  { print "sles" substr($2,6); exit; }
       ' /etc/SuSE-release`
    elif test -f /etc/os-release; then
      pp_rpm_distro="`. /etc/os-release && echo \$ID\$VERSION`"
    elif test -f /etc/pld-release; then
       pp_rpm_distro=`awk '
          /^[^ ]* PLD Linux/ { print "pld" $1; exit; }
       ' /etc/pld-release`
    elif test X"`uname -s 2>/dev/null`" = X"AIX"; then
	local r v
	r=`uname -r`
	v=`uname -v`
	pp_rpm_distro="aix$v$r"
    fi
    pp_rpm_distro=`echo $pp_rpm_distro | tr -d .`
    test -z "$pp_rpm_distro" &&
       pp_warn "unknown distro"
}

# Detect the rpmbuild program. On old systems, it is actually the `rpm`
# command. More recently it is called rpmbuild.
# Both are invoked the same way.
pp_rpm_detect_rpmbuild () {
    local cmd
    for cmd in rpmbuild rpm; do
        if command -v $cmd > /dev/null 2>&1; then
            echo $cmd
            return 0
        fi
    done

    pp_error "Could not find rpmbuild"
    # Default to `rpmbuild` in case it magically appears
    echo rpmbuild
    return 1
}

#@ pp_rpm_label(label [arg...]): writes "$label: $arg" for each non-empty arg
pp_rpm_label () {
    local label arg
    label="$1"; shift
    for arg
    do
        test -z "$arg" || echo "$label: $arg"
    done
}

#@ pp_rpm_writefiles() < %files: Write body of a %files section in RPM form
pp_rpm_writefiles () {
    local _l t m o g f p st fo farch
    while read t m o g f p st; do
        _l="$p"
	test $t = d && _l="%dir ${_l%/}/"
	if test $t = s; then
	    # rpm warns if %attr contains a mode for symlinks
	    m=-
        elif test x"$m" = x"-"; then
            case "$t" in
                d) m=755;;
                f) m=644;;
            esac
        fi
        test x"$o" = x"-" && o="${pp_rpm_defattr_uid:-root}"
        test x"$g" = x"-" && g="${pp_rpm_defattr_gid:-root}"
	_l="%attr($m,$o,$g) $_l"

	if test "$t" = "f" -a x"$pp_rpm_arch" = x"auto"; then
	    fo=`file "${pp_destdir}$p" 2>/dev/null`
	    #NB: The following should match executables and shared objects,
	    #relocatable objects. It will not match .a files however.
	    case "$fo" in
		*": ELF 32-bit LSB "*", Intel 80386"*)
		    farch=i386;;
		*": ELF 64-bit LSB "*", AMD x86-64"*|\
		*": ELF 64-bit LSB "*", x86-64"*)
		    farch=x86_64;;
		*": ELF 32-bit MSB "*", PowerPC"*)
		    farch=ppc;;
        *": ELF 64-bit LSB "*", 64-bit PowerPC"*)
            farch=ppc64le;;
		*": ELF 64-bit MSB "*", 64-bit PowerPC"*)
		    farch=ppc64;;
		*": ELF 64-bit LSB "*", IA-64"*)
		    farch=ia64;;
		*": ELF 32-bit MSB "*", IBM S/390"*)
		    farch=s390;;
		*": ELF 64-bit MSB "*", IBM S/390"*)
		    farch=s390x;;
		*"executable (RISC System/6000)"*)
		    farch=ppc;;
		*"64-bit XCOFF executable"*)
		    farch=ppc64;;
        *": ELF 64-bit LSB "*", ARM aarch64"*)
            farch=aarch64;;
		*" ELF "*)
		    farch=ELF;;
		*)
		    farch=noarch;;
	    esac
	    # If file(1) doesn't provide enough info, try readelf(1)
	    if test "$farch" = "ELF"; then
		fo=`readelf -h "${pp_destdir}$p" | awk '{if ($1 == "Class:") {class=$2} else if ($1 == "Machine:") {machine=$0; sub(/^ *Machine: */, "", machine)}} END {print class " " machine}' 2>/dev/null`
		case "$fo" in
		    "ELF32 Intel 80386")
			farch=i386;;
		    "ELF64 "*[xX]"86-64")
			farch=x86_64;;
		    "ELF32 PowerPC")
			farch=ppc;;
		    "ELF64 PowerPC"*)
			farch=ppc64;;
		    "ELF64 IA-64")
			farch=ia64;;
		    "ELF32 IBM S/390")
			farch=s390;;
		    "ELF64 IBM S/390")
			farch=s390x;;
            "ELF64 AArch64")
            farch=aarch64;;
		    *)
			farch=noarch;;
		esac
	    fi
	    pp_debug "file: $fo -> $farch"
	    test x"$farch" = x"noarch" || pp_add_to_list pp_rpm_arch_seen $farch
	fi

	case $f in *v*) _l="%config(noreplace) $_l";; esac
	echo "$_l"
    done
    echo
}

#@ pp_rpm_subname(component hyphen): translate cpt into a linux subpackage name
pp_rpm_subname () {
    case "$1" in
        run) : ;;
        dbg) echo "${2}${pp_rpm_dbg_pkgname}";;
        dev) echo "${2}${pp_rpm_dev_pkgname}";;
        doc) echo "${2}${pp_rpm_doc_pkgname}";;
        *)   pp_error "unknown component '$1'";
    esac
}

#@ pp_rpm_depend() < %depend: generate Requires rules
pp_rpm_depend () {
    local _name _vers
    while read _name _vers; do
        case "$_name" in ""| "#"*) continue ;; esac
        echo "Requires: $_name ${_vers:+>= $_vers}"
    done
}

#@ pp_rpm_conflict() < %conflict: generate Conflicts rules
pp_rpm_conflict () {
    local _name _vers
    while read _name _vers; do
        case "$_name" in ""| "#"*) continue ;; esac
        echo "Conflicts: $_name ${_vers:+>= $_vers}"
    done
}

#@ pp_rpm_override_requires(): generate spec section to override
#__find_requires if the package requires it
pp_rpm_override_requires () {
    local orig_find_requires

    if test -z "$pp_rpm_depend_filter_cmd"; then
	return 0
    fi

    orig_find_requires=`rpm --eval '%{__find_requires}'`
    cat << EOF > "$pp_wrkdir/filtered-find-requires"
#!/bin/sh
$orig_find_requires \$@ | $pp_rpm_depend_filter_cmd
EOF
    chmod +x "$pp_wrkdir/filtered-find-requires"
    echo "%define __find_requires $pp_wrkdir/filtered-find-requires"
    # Might be necessary for old versions of RPM? Not for 4.4.2.
    #echo "%define _use_internal_dependency_generator 0"
}

#@ pp_backend_rpm(): generate RPMs for the package
#-- Reads output files from the frontend and generates multiple output
#   package files under $pp_wrkdir/
pp_backend_rpm () {
    local cmp specfile _summary _group _desc _pkg _subname svc _script

	specfile=$pp_wrkdir/$name.spec
        : > $specfile

        #-- force existence of a 'run' component
        pp_add_component run
        : >> $pp_wrkdir/%files.run

	if test -z "$pp_rpm_arch"; then
            pp_error "Unknown RPM architecture"
            return 1
        fi

	#-- Write the header components of the RPM spec file
	cat <<-. >>$specfile
		Name: ${pp_rpm_name:-$name}
		Version: ${pp_rpm_version:-$version}
		Release: ${pp_rpm_release:-1}
		Summary: ${pp_rpm_summary:-$summary}
		Group:   ${pp_rpm_group}
		License: ${pp_rpm_license}
.
	pp_rpm_label "URL"              "$pp_rpm_url"             >>$specfile
	pp_rpm_label "Vendor"           "${pp_rpm_vendor:-$vendor}" >>$specfile
	pp_rpm_label "Packager"         "$pp_rpm_packager"        >>$specfile
	pp_rpm_label "Provides"         "$pp_rpm_provides"        >>$specfile
	pp_rpm_label "Requires(pre)"    "$pp_rpm_requires_pre"    >>$specfile
	pp_rpm_label "Requires(post)"   "$pp_rpm_requires_post"   >>$specfile
	pp_rpm_label "Requires(preun)"  "$pp_rpm_requires_preun"  >>$specfile
	pp_rpm_label "Requires(postun)" "$pp_rpm_requires_postun" >>$specfile
	pp_rpm_label "AutoProv"         "$pp_rpm_autoprov"        >>$specfile
	pp_rpm_label "AutoReq"          "$pp_rpm_autoreq"         >>$specfile
	pp_rpm_label "AutoReqProv"      "$pp_rpm_autoreqprov"     >>$specfile

	test -n "$pp_rpm_serial" && pp_warn "pp_rpm_serial deprecated"
	if test -n "$pp_rpm_epoch"; then
	    #-- Epoch was introduced in RPM 2.5.6
	    case `$pp_rpm_rpmbuild --version 2>/dev/null` in
		1.*|2.[0-5].*|2.5.[0-5])
		    pp_rpm_label "Serial" $pp_rpm_epoch >>$specfile;;
		*)
		    pp_rpm_label "Epoch" $pp_rpm_epoch >>$specfile;;
	    esac
	fi

        if test -n "$pp_rpm_requires"; then
            pp_rpm_label "Requires" "$pp_rpm_requires" >>$specfile
        elif test -s $pp_wrkdir/%depend.run; then
            pp_rpm_depend < $pp_wrkdir/%depend.run >> $specfile
        fi
        if test -s $pp_wrkdir/%conflict.run; then
            pp_rpm_conflict < $pp_wrkdir/%conflict.run >> $specfile
        fi

	pp_rpm_override_requires >> $specfile

	cat <<-. >>$specfile

		%description
		${pp_rpm_description:-$description}
.

	for cmp in $pp_components; do
		case $cmp in
		   run) continue;;
		   dev) _summary="development tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dev_group"
			_desc="${pp_rpm_dev_description:-Development libraries for $name. $pp_rpm_description.}"
		   	;;
		   doc) _summary="documentation for $pp_rpm_summary"
		   	_group="$pp_rpm_doc_group"
			_desc="${pp_rpm_doc_description:-Documentation for $name. $pp_rpm_description.}"
		   	;;
		   dbg) _summary="diagnostic tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dbg_group"
			_desc="${pp_rpm_dbg_description:-Diagnostic tools for $name.}"
		   	;;
		esac

                _subname=`pp_rpm_subname $cmp`
		cat <<-.

			%package $_subname
			Summary: $name $_summary
			Group: $_group
.
                for _script in pre post preun postun; do
                    eval '_pkg="$pp_rpm_'$cmp'_requires_'$_script'"'
                    if test -n "$_pkg"; then
                        eval pp_rpm_label "Requires($_script)" $_pkg
                    fi
                done
                eval '_pkg="$pp_rpm_'$cmp'_requires"'
                if test -n "$_pkg"; then
                    eval pp_rpm_label Requires ${pp_rpm_name:-$name} $_pkg
                elif test -s $pp_wrkdir/%depend.$cmp; then
                    pp_rpm_depend < $pp_wrkdir/%depend.$cmp >> $specfile
                fi
                if test -s $pp_wrkdir/%conflict.$cmp; then
                    pp_rpm_conflict < $pp_wrkdir/%conflict.$cmp >> $specfile
                fi

                eval '_pkg="$pp_rpm_'$cmp'_provides"'
		eval pp_rpm_label Provides $_pkg

		cat <<-.

			%description $_subname
			$_desc
.
	done >>$specfile

        #-- NB: we do not put any %prep, %build or %install RPM sections
	#   into the spec file.

        #-- add service start/stop code
        if test -n "$pp_services"; then
            pp_rpm_service_install_common >> $pp_wrkdir/%post.run

            #-- record the uninstall commands in reverse order
            for svc in $pp_services; do
                pp_load_service_vars $svc

                pp_rpm_service_make_service_files $svc ||
		    pp_error "could not create service files for $svc"

                #-- append %post code to install the svc
                pp_rpm_service_install $svc >> $pp_wrkdir/%post.run

                #-- prepend %preun code to uninstall svc
                # (use files in case vars are modified)
                pp_rpm_service_remove $svc | pp_prepend $pp_wrkdir/%preun.run
            done

            pp_rpm_service_remove_common | pp_prepend $pp_wrkdir/%preun.run
        fi

	# make convenience service groups
        if test -n "$pp_service_groups"; then
	    for grp in $pp_service_groups; do
		pp_rpm_service_group_make_init_script \
		    $grp "`pp_service_get_svc_group $grp`"
	    done
	fi

	#-- Write the RPM %file sections
        #   (do this after services, since services adds to %files.run)
	for cmp in $pp_components; do
            _subname=`pp_rpm_subname $cmp`

            if test -s $pp_wrkdir/%check.$cmp; then
                echo ""
                echo "%pre $_subname"
                cat $pp_wrkdir/%check.$cmp
                echo :   # causes script to exit true by default
            fi

            if test -s $pp_wrkdir/%files.$cmp; then
                echo ""
                echo "%files $_subname"
                pp_rpm_writefiles < $pp_wrkdir/%files.$cmp
            fi

            if test -n "$pp_rpm_ghost"; then
                for ghost in $pp_rpm_ghost; do
                    echo "%ghost $ghost"
                done
            fi

            if test -s $pp_wrkdir/%pre.$cmp; then
                echo ""
                echo "%pre $_subname"
                cat $pp_wrkdir/%pre.$cmp
                echo :   # causes script to exit true
            fi

            if test -s $pp_wrkdir/%post.$cmp; then
                echo ""
                echo "%post $_subname"
                cat $pp_wrkdir/%post.$cmp
                echo :   # causes script to exit true
            fi

            if test -s $pp_wrkdir/%preun.$cmp; then
                echo ""
                echo "%preun $_subname"
                cat $pp_wrkdir/%preun.$cmp
                echo :   # causes script to exit true
            fi

            if test -s $pp_wrkdir/%postun.$cmp; then
                echo ""
                echo "%postun $_subname"
                cat $pp_wrkdir/%postun.$cmp
                echo :   # causes script to exit true
            fi
	done >>$specfile

        #-- create a suitable work area for rpmbuild
	cat <<-. >$pp_wrkdir/.rpmmacros
		%_topdir $pp_wrkdir
		# XXX Note escaped %% for use in headerSprintf
		%_rpmfilename   %%{ARCH}/%%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm
	.
	mkdir $pp_wrkdir/RPMS
	mkdir $pp_wrkdir/BUILD

	if test x"$pp_rpm_arch" = x"auto"; then
	    #-- Reduce the arch_seen list to exactly one item
	    case "$pp_rpm_arch_seen" in
		"i386 x86_64"|"x86_64 i386")
		    pp_rpm_arch_seen=x86_64;;
		*"s390 s390x"* | *"s390x s390"* )
		    pp_rpm_arch_seen=s390x;;
        *"aarch64"* )
            pp_rpm_arch_seen=aarch64;;
		*" "*)
		    pp_error "detected multiple targets: $pp_rpm_arch_seen"
		    pp_rpm_arch_seen=unknown;;	    # not detected
		"")
		    pp_warn "detected no binaries: using target noarch"
		    pp_rpm_arch_seen=noarch;;
		*)
		    pp_debug "detected architecture $pp_rpm_arch_seen"
	    esac
	    pp_rpm_arch="$pp_rpm_arch_seen"
	fi

        . $pp_wrkdir/%fixup

$pp_opt_debug && cat $specfile

        pp_debug "creating: `pp_backend_rpm_names`"

pp_debug "pp_rpm_arch_seen = <${pp_rpm_arch_seen}>"
pp_debug "pp_rpm_arch = <${pp_rpm_arch}>"

	HOME=$pp_wrkdir \
	pp_verbose \
        $pp_rpm_rpmbuild -bb \
		--buildroot="$pp_destdir/" \
                --target="${pp_rpm_arch}" \
                --define='_unpackaged_files_terminate_build 0' \
                --define='_use_internal_dependency_generator 0' \
                `$pp_opt_debug && echo --verbose || echo --quiet` \
                $pp_rpm_rpmbuild_extra_flags \
		$specfile ||
            pp_error "Problem creating RPM packages"

	for f in `pp_backend_rpm_names`; do
	    # The package might be in an arch-specific subdir
	    pkgfile=not-found
	    for dir in $pp_wrkdir/RPMS/${pp_rpm_arch} $pp_wrkdir/RPMS; do
		if test -f $dir/$f; then
		    pkgfile=$dir/$f
		fi
	    done
	    if test x"$pkgfile" = x"not-found"; then
                pp_error "Problem predicting RPM filename: $f"
	    else
		ln $pkgfile $pp_wrkdir/$f
	    fi
	done
}

#@ pp_rpm_output_name($cpt): print the package names for the subpackage
pp_rpm_output_name () {
    echo "${pp_rpm_name:-$name}`pp_rpm_subname "$1" -`-${pp_rpm_version:-$version}-${pp_rpm_release:-1}.${pp_rpm_arch}.rpm"
}

#@ pp_backend_rpm_names(): print the package names generated
#   the names always start with $name-$version
pp_backend_rpm_names () {
    local cmp _subname
    for cmp in $pp_components; do
	pp_rpm_output_name $cmp
    done
}

pp_backend_rpm_cleanup () {
    :
}

#@ pp_rpm_print_requires(): prints the required features of the package
pp_rpm_print_requires () {
    local _subname _name

    echo "CPU:$pp_rpm_arch"
    ## XXX should be lines of the form (from file/ldd/objdump)
    #    EXEC:/bin/sh
    #    RTLD:libc.so.4:open
    rpm -q --requires -p $pp_wrkdir/`pp_rpm_output_name $1` |sed -e '/^rpmlib(/d;s/ //g;s/^/RPM:/' | sort -u
}

#@ pp_backend_rpm_install_script(): generate the install script
pp_backend_rpm_install_script () {
    local cmp _subname

    echo "#!/bin/sh"
    pp_install_script_common

    cat <<.

        cmp_to_pkgname () {
	    local oi name
	    if test x"\$1" = x"--only-installed"; then
		#-- only print if installation detected
		oi=false
		shift
	    else
		oi=true
	    fi
            test x"\$*" = x"all" &&
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        _subname=`pp_rpm_subname $cmp -`
         echo "$cmp) name=${pp_rpm_name:-$name}${_subname};;"
    done
    cat <<.
                *) usage;;
                esac
		if \$oi || rpm -q "\$name" >/dev/null 2>/dev/null; then
		    echo "\$name"
		fi
            done
        }


        cmp_to_pathname () {
            test x"\$*" = x"all" &&
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        echo "$cmp) echo \${PP_PKGDESTDIR:-.}/`pp_rpm_output_name $cmp` ;;"
    done
    cat <<.
                *) usage;;
                esac
            done
        }

	print_requires () {
            test x"\$*" = x"all" &&
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        echo "$cmp) cat <<'._end'"
	pp_rpm_print_requires $cmp
        echo "._end"; echo ';;'
    done
    cat <<.
                *) usage;;
                esac
            done
        }

        test \$# -eq 0 && usage
        op="\$1"; shift
        case "\$op" in
            list-components)
                test \$# -eq 0 || usage \$op
                echo $pp_components
                ;;
            list-services)
                test \$# -eq 0 || usage \$op
                echo $pp_services
                ;;
            list-files)
                test \$# -ge 1 || usage \$op
                cmp_to_pathname "\$@"
                ;;
            install)
                test \$# -ge 1 || usage \$op
                verbose rpm -U --replacepkgs --oldpackage \
                    \`cmp_to_pathname "\$@"\`
                ;;
            uninstall)
                test \$# -ge 1 || usage \$op
                pkgs=\`cmp_to_pkgname --only-installed "\$@"\`
                if test -z "\$pkgs"; then
                    verbosemsg "nothing to uninstall"
                else
                    verbose rpm -e \$pkgs
                fi
                ;;
            start|stop)
                test \$# -ge 1 || usage \$op
                ec=0
                for svc
                do
                    verbose /etc/init.d/\$svc \$op || ec=1
                done
                exit \$ec
                ;;
            print-platform)
                test \$# -eq 0 || usage \$op
		echo "linux-${pp_rpm_arch}"
		;;
            print-requires)
                test \$# -ge 1 || usage \$op
                print_requires "\$@"
		;;
            *)
                usage
                ;;
        esac
.

}

#@ pp_backend_rpm_probe(): print the local platform's short name
pp_backend_rpm_probe () {
        echo "${pp_rpm_distro}-${pp_rpm_arch_std}"
}

#@ pp_backend_rpm_vas_platforms(): print the VAS platform identifiers
pp_backend_rpm_vas_platforms () {
    case "$pp_rpm_arch_std" in
	x86_64)	echo "linux-x86_64.rpm linux-x86.rpm";;
	*86)	echo "linux-x86.rpm";;
	s390)	echo "linux-s390";;
	s390x)	echo "linux-s390x";;
	ppc*)	echo "linux-glibc23-ppc64 linux-glibc22-ppc64";;
	ia64)	echo "linux-ia64";;
	*)	pp_die "unknown architecture $pp_rpm_arch_std";;
    esac
}
